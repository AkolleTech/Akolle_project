# -*- coding: utf-8 -*-
"""iris.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MfqYKksJSaIMCKRtPGuQ7TsJyf1kybgG
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam
import pydot
import graphviz
from IPython.display import SVG
from tensorflow.keras.utils import plot_model
import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score
from tensorflow.keras.models import load_model
from sklearn.model_selection import cross_val_score


# show plot in the notebook
# %matplotlib inline

# Next, we'll load the Iris flower dataset, which is in the "../input/" directory
milk_data= pd.read_csv("/content/drive/MyDrive/honry.csv")

from google.colab import drive
drive.mount('/content/drive')

# first five observations
milk_data.head()

# Number of observations and missing values.
# There are 150 observations and no nan value
milk_data.info()

cal = milk_data['CONDUCTITY']
newco = cal/100
lig = milk_data['LIGHT']
newlig = lig/100

# Check basic description for features
milk_data1 = milk_data.drop(['CONDUCTITY','LIGHT'], axis=1)

milk_data1.insert(loc = 3, column = 'CONDUCTITY', value = newco)

milk_data1.insert(loc = 2, column = 'LIGHT', value = newlig)

milk_data1



# Check the response variable frequency
milk_data1['QUALITY'].value_counts()

# Create a pairplot of the data set. Which flower species seems to be the most separable?
sns.pairplot(milk_data1.drop(['no'], axis=1),hue='QUALITY')
# Iris setosa seems most separable from the other two species

iris_new = milk_data1.drop(['no'], axis=1)
correlation = iris_new.corr()

# constructing a heatmap to understand the correlation between the columns
plt.figure(figsize=(10,10))
sns.heatmap(correlation, cbar=True, square=True, fmt = '.1f', annot = True, annot_kws={'size':8}, cmap = 'Blues')

#Splitting the data into training and test
X = milk_data.drop(['no','QUALITY'],axis=1)
Y = milk_data['QUALITY']

from sklearn.preprocessing import LabelEncoder
encoder =  LabelEncoder()
y1 = encoder.fit_transform(Y)
Y = pd.get_dummies(y1).values

from sklearn.model_selection import train_test_split
X_train,X_test, y_train,y_test = train_test_split(X,Y,test_size=0.2,random_state=0)

#X
#y
#y1
Y
#len(X_test)

model = Sequential()

model.add(Dense(8,input_shape=(4,),activation='relu'))
model.add(Dense(6,activation='sigmoid'))
model.add(Dense(2,activation='sigmoid'))

model.compile(Adam(lr=0.04),'categorical_crossentropy',metrics=['accuracy'])

model.summary()

plot_model(model, to_file='model_plot.png', show_shapes=True, show_layer_names=True)
from IPython.display import Image
Image(filename='model_plot.png')

from IPython.display import SVG
from keras.utils.vis_utils import model_to_dot

SVG(model_to_dot(model).create(prog='dot', format='svg'))

history = model.fit(X_train,
                    y_train,
                    validation_split = 0.2,
                    epochs=400)

#score = cross_val_score(history,X_train,y_train,scor)

loss = history.history["loss"]
val_loss = history.history["val_loss"]
accuracy = history.history["accuracy"]
val_accuracy = history.history["val_accuracy"]
epochs = range(1,len(loss)+1)

plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.title("Loss Graph")
plt.plot(epochs,loss)
plt.plot(epochs,val_loss)
plt.legend(["this is loss","this is Val_loss"])

plt.xlabel("Epochs")
plt.ylabel("Accracy")
plt.title("Accuracy Graph")
plt.plot(epochs,accuracy)
plt.plot(epochs,val_accuracy)
plt.legend(["this is accuracy","this is val_accuracy"])

y_pred = model.predict(X_test)
y_test_class = np.argmax(y_test,axis=1)
y_pred_class = np.argmax(y_pred,axis=1)

# accuracy on test data

test_data_accuracy = accuracy_score(y_pred_class,y_test_class)

test_data_accuracy

#Accuracy of the predicted values
from sklearn.metrics import classification_report,confusion_matrix
print(classification_report(y_test_class,y_pred_class))
cm = confusion_matrix(y_test_class,y_pred_class)
sns.heatmap(cm,annot=True,fmt = "",cmap="Blues")

X_test2 = np.array([[5.6,2.211914063,43,14.53,6.2]])#0,1,2
y_pred2 = model.predict(X_test2)
y_pred2

result = np.argmax(y_pred2,axis=1)[0]

if result == 0:
  print("its bad")
else:
  print("its good")

model.save("/content/honeyss.h5")

new_model = load_model("/content/honeyss.h5")

X_test2 = np.array([[6.0,3.0,4.8,1.8,5]])#0,1,2
y_pred2 = new_model.predict(X_test2)
result = np.argmax(y_pred2,axis=1)[0]

if result == 0:
  print("its bad")
else:
  print("its good")

import tensorflow as tf

model = tf.keras.models.load_model("/content/honeyss.h5")
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()
open("/content/honeyss.tflite", "wb").write(tflite_model)

